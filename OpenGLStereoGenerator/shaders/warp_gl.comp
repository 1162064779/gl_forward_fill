#version 430

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) uniform sampler2D srcColor;

layout(binding = 2, rgba8) writeonly  uniform image2D  dstColor;
layout(binding = 3, r32ui) coherent   uniform uimage2D dstDepth;
layout(binding = 4, r32ui)            uniform uimage2D dstIndex;

uniform int   orgWidth;
uniform int   orgHeight;
uniform int   padSizeX;
uniform int   padSizeY;
uniform int   paddedWidth;
uniform int   paddedHeight;
uniform float shiftScaleX;
uniform float shiftBiasX;
uniform float shiftScaleY;
uniform float shiftBiasY;

uint encodeDepth(float d)
{
    return uint(clamp(d, 0.0, 1.0) * 255.0);
}

void tryWrite(ivec2 paddedPos, vec4 c, uint dEnc, uint idx)
{
    bool inside =
         paddedPos.x >= padSizeX &&
         paddedPos.x <  padSizeX + orgWidth &&
         paddedPos.y >= padSizeY &&
         paddedPos.y <  padSizeY + orgHeight;

    if (!inside) return;

    ivec2 dstPos = ivec2(paddedPos.x - padSizeX,
                         paddedPos.y - padSizeY);

    uint old = imageAtomicMax(dstDepth, dstPos, dEnc);
    if (dEnc > old || old == 0u) {
        // 确保原子写对后续的 imageLoad 可见
        memoryBarrier();

        if (imageLoad(dstDepth, dstPos).r == dEnc) {
            imageStore(dstColor, dstPos, vec4(c.rgb, 1.0));
            imageStore(dstIndex, dstPos, uvec4(idx, 0u, 0u, 0u));

            // 双检兜底：若被更大深度抢占，则标记
            if (imageLoad(dstDepth, dstPos).r != dEnc) {
                imageStore(dstDepth, dstPos, uvec4(dEnc, 0u, 0u, 0u));
                imageStore(dstIndex, dstPos, uvec4(0xFFFFFFFFu, 0u, 0u, 0u));
            }
        }
    }
}

void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (gid.x >= uint(paddedWidth) || gid.y >= uint(paddedHeight)) return;

    int srcX = clamp(int(gid.x) - padSizeX, 0, orgWidth  - 1);
    int srcY = clamp(int(gid.y) - padSizeY, 0, orgHeight - 1);

    vec4  C = texelFetch(srcColor, ivec2(srcX, srcY), 0);
    float Z = texelFetch(srcColor, ivec2(srcX + orgWidth, srcY), 0).r;

    float dispX = Z * shiftScaleX + shiftBiasX;
    float dispY = Z * shiftScaleY + shiftBiasY;

    float xPrime = float(gid.x) + dispX;
    float yPrime = float(gid.y) + dispY;

    int   xFloor = int(floor(xPrime));
    int   yFloor = int(floor(yPrime));
    float fracX  = fract(xPrime);
    float fracY  = fract(yPrime);

    uint dEnc = encodeDepth(Z);
    uint idx  = uint(srcY) * uint(orgWidth) + uint(srcX);

    tryWrite(ivec2(xFloor    , yFloor    ), C, dEnc, idx);
    if (fracX > 0.001)                  tryWrite(ivec2(xFloor + 1, yFloor    ), C, dEnc, idx);
    if (fracY > 0.001)                  tryWrite(ivec2(xFloor    , yFloor + 1), C, dEnc, idx);
    if (fracX > 0.001 && fracY > 0.001) tryWrite(ivec2(xFloor + 1, yFloor + 1), C, dEnc, idx);
}