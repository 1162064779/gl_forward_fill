#version 320 es
precision highp float;
precision highp int;
precision highp uint;

layout(local_size_x = 16, local_size_y = 16) in;

/* ---------- 输入纹理 ---------- */
layout(binding = 0) uniform highp sampler2D srcColor;

/* ---------- 输出 image ---------- */
layout(binding = 2, rgba8) writeonly  uniform highp image2D  dstColor;
layout(binding = 3, r32ui) readonly   uniform highp uimage2D dstDepth;
layout(binding = 4, r32ui) writeonly  uniform highp uimage2D dstIndex;

/* ---------- 公共参数 ---------- */
uniform int   orgWidth,  orgHeight;
uniform int   padSizeX,  padSizeY;
uniform int   paddedWidth, paddedHeight;
uniform float shiftScaleX, shiftBiasX;
uniform float shiftScaleY, shiftBiasY;

/* ---------- 工具 ---------- */
uint encodeDepth(float d) { return uint(clamp(d, 0.0, 1.0) * 255.0); }

/* ---------- 深度匹配后写颜色 ---------- */
void tryWriteColor(ivec2 paddedPos, vec4 C, uint dEnc, uint idx)
{
    bool inside =
         paddedPos.x >= padSizeX &&
         paddedPos.x <  padSizeX + orgWidth &&
         paddedPos.y >= padSizeY &&
         paddedPos.y <  padSizeY + orgHeight;
    if (!inside) return;

    ivec2 dstPos = ivec2(paddedPos.x - padSizeX,
                         paddedPos.y - padSizeY);

    if (dEnc == imageLoad(dstDepth, dstPos).r)
    {
        imageStore(dstColor, dstPos, vec4(C.rgb, 1.0));
        imageStore(dstIndex, dstPos, uvec4(idx, 0u, 0u, 0u));
    }
}

/* ---------- 主函数 ---------- */
void main()
{
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= paddedWidth || gid.y >= paddedHeight) return;

    int srcX = clamp(gid.x - padSizeX, 0, orgWidth  - 1);
    int srcY = clamp(gid.y - padSizeY, 0, orgHeight - 1);

    vec4  C = texelFetch(srcColor, ivec2(srcX, srcY), 0);
    float Z = texelFetch(srcColor, ivec2(srcX + orgWidth, srcY), 0).r;

    float dispX = Z * shiftScaleX + shiftBiasX;
    float dispY = Z * shiftScaleY + shiftBiasY;
    float xPrime = float(gid.x) + dispX;
    float yPrime = float(gid.y) + dispY;

    int   xFloor = int(floor(xPrime));
    int   yFloor = int(floor(yPrime));
    float fracX  = fract(xPrime);
    float fracY  = fract(yPrime);

    uint dEnc = encodeDepth(Z);
    uint idx  = uint(srcY) * uint(orgWidth) + uint(srcX);

    tryWriteColor(ivec2(xFloor    , yFloor    ), C, dEnc, idx);
    if (fracX > 0.001)                  tryWriteColor(ivec2(xFloor + 1, yFloor    ), C, dEnc, idx);
    if (fracY > 0.001)                  tryWriteColor(ivec2(xFloor    , yFloor + 1), C, dEnc, idx);
    if (fracX > 0.001 && fracY > 0.001) tryWriteColor(ivec2(xFloor + 1, yFloor + 1), C, dEnc, idx);
}