#version 320 es
/* ------------------------------------------------------------ */
/* 1. 公共精度声明                                              */
/* ------------------------------------------------------------ */
precision highp float;
precision highp int;
precision highp uint;

/* ------------------------------------------------------------ */
/* 2. 工作组大小                                                */
/* ------------------------------------------------------------ */
layout(local_size_x = 16, local_size_y = 16) in;

/* ------------------------------------------------------------ */
/* 3. 输入纹理                                                  */
/*      颜色+深度仍然存放在同一张 RGBA8 纹理：                    */
/*      [0 .. orgWidth-1]            → rgb 颜色 + a  8-bit Z     */
/*      [orgWidth .. 2*orgWidth-1]   → r   通道存深度             */
/* ------------------------------------------------------------ */
layout(binding = 0) uniform highp sampler2D srcColor;

/* ------------------------------------------------------------ */
/* 4. 输出 image                                                */
/* ------------------------------------------------------------ */
layout(binding = 2, rgba8) writeonly  uniform highp image2D  dstColor;
layout(binding = 3, r32ui) coherent   uniform highp uimage2D dstDepth;
/* ------------------------------------------------------------
   工具：归一化深度 → uint32，供 imageAtomicMax 使用
   ③ 4 294 967 295 在 32-bit float 中仍可准确到个位数，
     但为了保险，这里写成 4294967295.0f
   ------------------------------------------------------------ */
/* α 只有 0-255 级，但 atomicMax 仍要求 32 bit 格式，所以依旧扩展到 32 bit */
layout(binding = 4, r32ui)            uniform highp uimage2D dstIndex;  // 保存 (y * W + x)

/* ------------------------------------------------------------ */
/* 5. 尺寸 / Pad / 位移参数                                     */
/* ------------------------------------------------------------ */
uniform int   orgWidth;          // 原始图宽
uniform int   orgHeight;         // 原始图高

uniform int   padSizeX;          // 左右复制宽度
uniform int   padSizeY;          // 上下复制高度
uniform int   paddedWidth;       // = orgWidth  + 2 * padSizeX
uniform int   paddedHeight;      // = orgHeight + 2 * padSizeY

uniform float shiftScaleX;       // dispX = Z * kx + bx
uniform float shiftBiasX;
uniform float shiftScaleY;       // dispY = Z * ky + by
uniform float shiftBiasY;

/* ------------------------------------------------------------ */
/*                6.  工具：深度编码 (8-bit→32-bit)              */
/* ------------------------------------------------------------ */
uint encodeDepth(highp float d)             // d ∈ [0,1]
{
    return uint(clamp(d, 0.0, 1.0) * 255.0 );
    /* 0-16,777,215 (2^24-1) 仍放在 32-bit 里供 atomicMax 比较 */
    // return uint(clamp(d, 0.0, 1.0) * 16777215.0);
}

/* ------------------------------------------------------------ */
/* 7. 写出一个像素（深度竞争）                                  */
/*   参数 paddedPos 在「带 Pad 的坐标系」                         */
/* ------------------------------------------------------------ */
void tryWrite(ivec2 paddedPos, vec4 c, uint dEnc, uint idx)
{
    /* 1) 过滤四周 Pad，确认在有效输出范围 */
    bool inside =
         paddedPos.x >= padSizeX &&
         paddedPos.x <  padSizeX + orgWidth &&
         paddedPos.y >= padSizeY &&
         paddedPos.y <  padSizeY + orgHeight;

    if (!inside) return;

    /* 2) 去掉 Pad 偏移，映射到 [0,org-1] */
    ivec2 dstPos = ivec2(paddedPos.x - padSizeX,
                         paddedPos.y - padSizeY);

    /* 3) 深度原子竞争，保留 dEnc 较大的像素 */
    uint old = imageAtomicMax(dstDepth, dstPos, dEnc);
    if (dEnc > old || old == 0u) {
        memoryBarrier();    // 把 atomicMax 写入的深度冲刷到全局缓存，保证 *本线程*
                            // 后面的 imageLoad 读到最新值；其它线程要想看到，也得
                            // 在各自读取前执行 memoryBarrier()/Acquire-load。
        if (imageLoad(dstDepth, dstPos).r == dEnc) {  // 仍然是我？
            imageStore(dstColor, dstPos, vec4(c.rgb, 1.0));
            imageStore(dstIndex, dstPos, uvec4(idx, 0u, 0u, 0u));
            if (imageLoad(dstDepth, dstPos).r != dEnc) {//假设有深度小的a和深度大的b，a先执行了81-86行的逻辑，b后执行，但b先执行了87行，导致深度为b的，颜色却为a的，对于这种清空，把index置空，可以在fill中补齐
                imageStore(dstDepth, dstPos, uvec4(dEnc, 0u, 0u, 0u));
                imageStore(dstIndex, dstPos, uvec4(0xFFFFFFFF, 0u, 0u, 0u));
            }
        }
    }
}

/* ------------------------------------------------------------ */
/* 8. 主函数                                                    */
/* ------------------------------------------------------------ */
void main()
{
    /* -------- 8.1 线程 ID 与越界裁剪 -------- */
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    if (gid.x >= paddedWidth || gid.y >= paddedHeight) return;

    /* -------- 8.2 反向映射到源图像坐标 --------
       把 replication-pad 去掉后再 clamp */
    int srcX = clamp(gid.x - padSizeX, 0, orgWidth  - 1);
    int srcY = clamp(gid.y - padSizeY, 0, orgHeight - 1);

    /* -------- 8.3 读取颜色 + 深度 ------------ */
    vec4 C  = texelFetch(srcColor, ivec2(srcX, srcY), 0);              // 左幅颜色
    float Z = texelFetch(srcColor, ivec2(srcX + orgWidth, srcY), 0).r;
    // vec4 DZ = texelFetch(srcColor, ivec2(srcX + orgWidth, srcY), 0);   // 右幅 RGB 深度

    /* -------- 8.4 计算水平 / 垂直位移 -------- */
    // /* R/G/B ∈[0,1] → 0-255 uint */
    // uint zR = uint(DZ.r * 255.0 + 0.5);   // 高 8 位
    // uint zG = uint(DZ.g * 255.0 + 0.5);   // 中 8 位
    // uint zB = uint(DZ.b * 255.0 + 0.5);   // 低 8 位

    // uint z24 = (zR << 16) | (zG << 8) | zB;           // 0-16,777,215
    // float Z  = float(z24) / 16777215.0;               // 归一化深度

    float dispX = Z * shiftScaleX + shiftBiasX;
    float dispY = Z * shiftScaleY + shiftBiasY;

    float xPrime = float(gid.x) + dispX;
    float yPrime = float(gid.y) + dispY;

    int   xFloor = int(floor(xPrime));
    int   yFloor = int(floor(yPrime));

    float fracX  = fract(xPrime);
    float fracY  = fract(yPrime);

    /* -------- 8.5 深度编码 & 像素索引 ------- */
    uint dEnc = encodeDepth(Z);
    uint idx  = uint(srcY) * uint(orgWidth) + uint(srcX);  // 打平索引

    /* 8.6 写 4 个像素（双线性裂变） */
    tryWrite(ivec2(xFloor    , yFloor    ), C, dEnc, idx);

    /* (xFloor+1, yFloor)                        */
    if (fracX > 0.001)
        tryWrite(ivec2(xFloor + 1, yFloor    ), C, dEnc, idx);

    /* (xFloor, yFloor+1)                        */
    if (fracY > 0.001)
        tryWrite(ivec2(xFloor    , yFloor + 1), C, dEnc, idx);

    /* (xFloor+1, yFloor+1)                      */
    if (fracX > 0.001 && fracY > 0.001)
        tryWrite(ivec2(xFloor + 1, yFloor + 1), C, dEnc, idx);
}